// To use SLURM succesfully, run nextflow from an sbatch script with the 
// pertinant details for your computing cluster.
process {
      clusterOptions = '--ntasks=1 --nodes=1'
      errorStrategy = 'retry'  // Prevent Nextflow from exiting on submission error
      maxRetries = 3           // If submission fails, Nextflow tries again
}

// Increase polling time to prevent timeout errors
executor {
    name = 'slurm'
    submitTimeout = '3 min'          // Increase SLURM job submission timeout
    pollInterval = '30 sec'  // Check queue less frequently
    perCpuMemAllocation = false
    queueSize = 10
}


process {
    withLabel: nano {
        cpus   1
        memory { 512.MB  * Math.pow(1.5, task.attempt-1) }
        time   {  5.m    * (long) Math.pow(2,   task.attempt-1) }
    }

    withLabel: micro {
        cpus   1
        memory {   2.GB  * Math.pow(1.5, task.attempt-1) }
        time   { 45.m    * (long) Math.pow(2,   task.attempt-1) }
    }

    withLabel: small {
        cpus   2
        memory {   8.GB  * Math.pow(1.5, task.attempt-1) }
        time   {  3.h    * (long) Math.pow(2,   task.attempt-1) }
    }

    withLabel: medium {
        cpus   10
        memory {  24.GB  * Math.pow(1.5, task.attempt-1) }
        time   {  6.h    * (long) Math.pow(2,   task.attempt-1) }
    }

    withLabel: large_short {
        cpus   20
        memory {  64.GB  * Math.pow(1.2, task.attempt-1) }
        time   { 2.h    * (long) Math.pow(2,   task.attempt-1) }
    }

    withLabel: large {
        cpus   10
        memory {  64.GB  * Math.pow(1.5, task.attempt-1) }
        time   { 24.h    * (long) Math.pow(2,   task.attempt-1) }
    }

    withLabel: xlarge {
        cpus   32
        memory { 256.GB  * Math.pow(1.5, task.attempt-1) }
        time   { 72.h    * (long) Math.pow(2,   task.attempt-1) }
    }
    withLabel: large_memory {
        cpus = params.threads
        memory = '250 GB'
        time = '2h'
    }
    withLabel: medium_memory {
        cpus = params.threads
        memory = '100 GB'
        time = '2h'
    }
    withLabel: dedup {
        cpus = 12
        memory = '50 GB'
        time = '2h'
    }
    withLabel: small_memory_medium_time {
        cpus = params.threads
        memory = '50 GB'
        time = '6h'
    }
    withLabel: small_memory {
        cpus = params.threads
        memory = '80 GB'
        time = '6h'
    }
    withLabel: small_memory_short_time {
        cpus = params.threads
        memory = '20 GB'
        time = '1h'
    }
    withLabel: small_memory_long_time {
        cpus = params.threads
        memory = '60 GB'
        time = '8h'
        /* --- retry policy -------------------------------------------------- */
        // Retry once only when the task is killed for OOM or wall-time (exit 137–140)
        errorStrategy = { task.exitStatus in 137..140 ? 'retry' : 'terminate' }
        maxRetries    = 1

        /* --- scale resources by 1.5× on the retry ------------------------- */
        memory = { 60.GB * (task.attempt > 1 ? 1.5 : 1) }
        time   = {  8.h   * (task.attempt > 1 ? 1.5 : 1) }

    }

}